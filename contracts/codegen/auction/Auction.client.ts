/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Decimal, Addr, Config, Uint128, DebtAuction, RepayPosition, UserInfo, AuctionRecipient, ExecuteMsg, AssetInfo, Asset, UpdateConfig, FeeAuction, InstantiateMsg, QueryMsg } from "./Auction.types";
export interface AuctionReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  debtAuction: () => Promise<DebtAuction>;
  ongoingFeeAuctions: ({
    auctionAsset,
    limit,
    startAfter
  }: {
    auctionAsset?: AssetInfo;
    limit?: number;
    startAfter?: number;
  }) => Promise<FeeAuction>;
}
export class AuctionQueryClient implements AuctionReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.debtAuction = this.debtAuction.bind(this);
    this.ongoingFeeAuctions = this.ongoingFeeAuctions.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  debtAuction = async (): Promise<DebtAuction> => {
    return this.client.queryContractSmart(this.contractAddress, {
      debt_auction: {}
    });
  };
  ongoingFeeAuctions = async ({
    auctionAsset,
    limit,
    startAfter
  }: {
    auctionAsset?: AssetInfo;
    limit?: number;
    startAfter?: number;
  }): Promise<FeeAuction> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ongoing_fee_auctions: {
        auction_asset: auctionAsset,
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface AuctionInterface extends AuctionReadOnlyInterface {
  contractAddress: string;
  sender: string;
  startAuction: ({
    auctionAsset,
    repaymentPositionInfo,
    sendTo
  }: {
    auctionAsset: Asset;
    repaymentPositionInfo?: UserInfo;
    sendTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  swapForMBRN: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  swapForFee: ({
    auctionAsset
  }: {
    auctionAsset: AssetInfo;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeAuction: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    cdtDenom,
    desiredAsset,
    discountIncrease,
    discountIncreaseTimeframe,
    governanceContract,
    initialDiscount,
    mbrnDenom,
    oracleContract,
    osmosisProxy,
    owner,
    positionsContract,
    sendToStakers,
    stakingContract,
    twapTimeframe
  }: {
    cdtDenom?: string;
    desiredAsset?: string;
    discountIncrease?: Decimal;
    discountIncreaseTimeframe?: number;
    governanceContract?: string;
    initialDiscount?: Decimal;
    mbrnDenom?: string;
    oracleContract?: string;
    osmosisProxy?: string;
    owner?: string;
    positionsContract?: string;
    sendToStakers?: boolean;
    stakingContract?: string;
    twapTimeframe?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class AuctionClient extends AuctionQueryClient implements AuctionInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.startAuction = this.startAuction.bind(this);
    this.swapForMBRN = this.swapForMBRN.bind(this);
    this.swapForFee = this.swapForFee.bind(this);
    this.removeAuction = this.removeAuction.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
  }

  startAuction = async ({
    auctionAsset,
    repaymentPositionInfo,
    sendTo
  }: {
    auctionAsset: Asset;
    repaymentPositionInfo?: UserInfo;
    sendTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      start_auction: {
        auction_asset: auctionAsset,
        repayment_position_info: repaymentPositionInfo,
        send_to: sendTo
      }
    }, fee, memo, _funds);
  };
  swapForMBRN = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap_for_m_b_r_n: {}
    }, fee, memo, _funds);
  };
  swapForFee = async ({
    auctionAsset
  }: {
    auctionAsset: AssetInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap_for_fee: {
        auction_asset: auctionAsset
      }
    }, fee, memo, _funds);
  };
  removeAuction = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_auction: {}
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    cdtDenom,
    desiredAsset,
    discountIncrease,
    discountIncreaseTimeframe,
    governanceContract,
    initialDiscount,
    mbrnDenom,
    oracleContract,
    osmosisProxy,
    owner,
    positionsContract,
    sendToStakers,
    stakingContract,
    twapTimeframe
  }: {
    cdtDenom?: string;
    desiredAsset?: string;
    discountIncrease?: Decimal;
    discountIncreaseTimeframe?: number;
    governanceContract?: string;
    initialDiscount?: Decimal;
    mbrnDenom?: string;
    oracleContract?: string;
    osmosisProxy?: string;
    owner?: string;
    positionsContract?: string;
    sendToStakers?: boolean;
    stakingContract?: string;
    twapTimeframe?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        cdt_denom: cdtDenom,
        desired_asset: desiredAsset,
        discount_increase: discountIncrease,
        discount_increase_timeframe: discountIncreaseTimeframe,
        governance_contract: governanceContract,
        initial_discount: initialDiscount,
        mbrn_denom: mbrnDenom,
        oracle_contract: oracleContract,
        osmosis_proxy: osmosisProxy,
        owner,
        positions_contract: positionsContract,
        send_to_stakers: sendToStakers,
        staking_contract: stakingContract,
        twap_timeframe: twapTimeframe
      }
    }, fee, memo, _funds);
  };
}