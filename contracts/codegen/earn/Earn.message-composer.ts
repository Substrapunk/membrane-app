/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "@cosmjs/cosmwasm-stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { Decimal, APRResponse, Addr, Uint128, Config, VaultInfo, ExecuteMsg, InstantiateMsg, QueryMsg } from "./Earn.types";
export interface EarnMsg {
  contractAddress: string;
  sender: string;
  enterVault: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  exitVault: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  unloopCDP: ({
    desiredCollateralWithdrawal
  }: {
    desiredCollateralWithdrawal: Uint128;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  loopCDP: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  rateAssurance: ({
    exit
  }: {
    exit: boolean;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  updateNonleveragedVaultTokens: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class EarnMsgComposer implements EarnMsg {
  sender: string;
  contractAddress: string;

  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.enterVault = this.enterVault.bind(this);
    this.exitVault = this.exitVault.bind(this);
    this.unloopCDP = this.unloopCDP.bind(this);
    this.loopCDP = this.loopCDP.bind(this);
    this.rateAssurance = this.rateAssurance.bind(this);
    this.updateNonleveragedVaultTokens = this.updateNonleveragedVaultTokens.bind(this);
  }

  enterVault = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          enter_vault: {}
        })),
        funds: _funds
      })
    };
  };
  exitVault = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          exit_vault: {}
        })),
        funds: _funds
      })
    };
  };
  unloopCDP = ({
    desiredCollateralWithdrawal
  }: {
    desiredCollateralWithdrawal: Uint128;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          unloop_c_d_p: {
            desired_collateral_withdrawal: desiredCollateralWithdrawal
          }
        })),
        funds: _funds
      })
    };
  };
  loopCDP = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          loop_c_d_p: {}
        })),
        funds: _funds
      })
    };
  };
  rateAssurance = ({
    exit
  }: {
    exit: boolean;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          rate_assurance: {
            exit
          }
        })),
        funds: _funds
      })
    };
  };
  updateNonleveragedVaultTokens = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_nonleveraged_vault_tokens: {}
        })),
        funds: _funds
      })
    };
  };
}