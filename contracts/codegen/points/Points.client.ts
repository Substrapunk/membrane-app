/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Uint256, Addr, ClaimCheck, ClaimsResponse, Coin, Decimal, Config, ExecuteMsg, InstantiateMsg, QueryMsg, UserStatsResponse, UserStats } from "./Points.types";
import { UserInfo } from "../positions/Positions.types";
export interface PointsReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  claimCheck: () => Promise<ClaimCheck>;
  userStats: ({
    limit,
    startAfter,
    user
  }: {
    limit?: number;
    startAfter?: string;
    user?: string;
  }) => Promise<UserStatsResponse[]>;
}
export class PointsQueryClient implements PointsReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.claimCheck = this.claimCheck.bind(this);
    this.userStats = this.userStats.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  claimCheck = async (): Promise<ClaimCheck> => {
    return this.client.queryContractSmart(this.contractAddress, {
      claim_check: {}
    });
  };
  userStats = async ({
    limit,
    startAfter,
    user
  }: {
    limit?: number;
    startAfter?: string;
    user?: string;
  }): Promise<UserStatsResponse[]> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_stats: {
        limit,
        start_after: startAfter,
        user
      }
    });
  };
}
export interface PointsInterface extends PointsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    cdtDenom,
    governanceContract,
    liqQueueContract,
    maxMbrnDistribution,
    mbrnPerPoint,
    oracleContract,
    osmosisProxyContract,
    owner,
    pointsPerDollar,
    positionsContract,
    stabilityPoolContract,
    totalMbrnDistribution
  }: {
    cdtDenom?: string;
    governanceContract?: string;
    liqQueueContract?: string;
    maxMbrnDistribution?: Uint128;
    mbrnPerPoint?: Decimal;
    oracleContract?: string;
    osmosisProxyContract?: string;
    owner?: string;
    pointsPerDollar?: Decimal;
    positionsContract?: string;
    stabilityPoolContract?: string;
    totalMbrnDistribution?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  checkClaims: ({
    cdpRepayment,
    lqClaims,
    spClaims,
    vote
  }: {
    cdpRepayment: UserInfo | undefined;
    lqClaims: boolean;
    spClaims: boolean;
    vote?: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  givePoints: ({
    cdpRepayment,
    lqClaims,
    spClaims,
    vote
  }: {
    cdpRepayment: boolean;
    lqClaims: boolean;
    spClaims: boolean;
    vote?: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liquidate: ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimMBRN: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class PointsClient extends PointsQueryClient implements PointsInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.checkClaims = this.checkClaims.bind(this);
    this.givePoints = this.givePoints.bind(this);
    this.liquidate = this.liquidate.bind(this);
    this.claimMBRN = this.claimMBRN.bind(this);
  }

  updateConfig = async ({
    cdtDenom,
    governanceContract,
    liqQueueContract,
    maxMbrnDistribution,
    mbrnPerPoint,
    oracleContract,
    osmosisProxyContract,
    owner,
    pointsPerDollar,
    positionsContract,
    stabilityPoolContract,
    totalMbrnDistribution
  }: {
    cdtDenom?: string;
    governanceContract?: string;
    liqQueueContract?: string;
    maxMbrnDistribution?: Uint128;
    mbrnPerPoint?: Decimal;
    oracleContract?: string;
    osmosisProxyContract?: string;
    owner?: string;
    pointsPerDollar?: Decimal;
    positionsContract?: string;
    stabilityPoolContract?: string;
    totalMbrnDistribution?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        cdt_denom: cdtDenom,
        governance_contract: governanceContract,
        liq_queue_contract: liqQueueContract,
        max_mbrn_distribution: maxMbrnDistribution,
        mbrn_per_point: mbrnPerPoint,
        oracle_contract: oracleContract,
        osmosis_proxy_contract: osmosisProxyContract,
        owner,
        points_per_dollar: pointsPerDollar,
        positions_contract: positionsContract,
        stability_pool_contract: stabilityPoolContract,
        total_mbrn_distribution: totalMbrnDistribution
      }
    }, fee, memo, _funds);
  };
  checkClaims = async ({
    cdpRepayment,
    lqClaims,
    spClaims,
    vote
  }: {
    cdpRepayment: UserInfo | undefined;
    lqClaims: boolean;
    spClaims: boolean;
    vote?: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      check_claims: {
        cdp_repayment: cdpRepayment,
        lq_claims: lqClaims,
        sp_claims: spClaims,
        vote
      }
    }, fee, memo, _funds);
  };
  givePoints = async ({
    cdpRepayment,
    lqClaims,
    spClaims,
    vote
  }: {
    cdpRepayment: boolean;
    lqClaims: boolean;
    spClaims: boolean;
    vote?: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      give_points: {
        cdp_repayment: cdpRepayment,
        lq_claims: lqClaims,
        sp_claims: spClaims,
        vote
      }
    }, fee, memo, _funds);
  };
  liquidate = async ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liquidate: {
        position_id: positionId,
        position_owner: positionOwner
      }
    }, fee, memo, _funds);
  };
  claimMBRN = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_m_b_r_n: {}
    }, fee, memo, _funds);
  };
}