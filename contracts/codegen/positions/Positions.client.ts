/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Decimal, Uint128, NativeToken, Addr, BasketPositionsResponse, PositionResponse, CAsset, Asset, PoolInfo, Basket, SupplyCap, MultiAssetSupplyCap, CollateralInterestResponse, Config, DebtCap, ExecuteMsg, PoolType, CallbackMsg, UpdateConfig, EditBasket, TWAPPoolInfo, InstantiateMsg, InterestResponse, QueryMsg, UserInfo, RedeemabilityResponse, PremiumInfo, RedemptionInfo, PositionRedemption } from "./Positions.types";
export interface PositionsReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  getBasketRedeemability: ({
    limit,
    positionOwner,
    startAfter
  }: {
    limit?: number;
    positionOwner?: string;
    startAfter?: number;
  }) => Promise<RedeemabilityResponse>;
  getBasketPositions: ({
    limit,
    startAfter,
    user,
    userInfo
  }: {
    limit?: number;
    startAfter?: string;
    user?: string;
    userInfo?: UserInfo;
  }) => Promise<BasketPositionsResponse[]>;
  getBasket: () => Promise<Basket>;
  getBasketDebtCaps: () => Promise<DebtCap[]>;
  getCreditRate: () => Promise<InterestResponse>;
  getCollateralInterest: () => Promise<CollateralInterestResponse>;
}
export class PositionsQueryClient implements PositionsReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.getBasketRedeemability = this.getBasketRedeemability.bind(this);
    this.getBasketPositions = this.getBasketPositions.bind(this);
    this.getBasket = this.getBasket.bind(this);
    this.getBasketDebtCaps = this.getBasketDebtCaps.bind(this);
    this.getCreditRate = this.getCreditRate.bind(this);
    this.getCollateralInterest = this.getCollateralInterest.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  getBasketRedeemability = async ({
    limit,
    positionOwner,
    startAfter
  }: {
    limit?: number;
    positionOwner?: string;
    startAfter?: number;
  }): Promise<RedeemabilityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_redeemability: {
        limit,
        position_owner: positionOwner,
        start_after: startAfter
      }
    });
  };
  getBasketPositions = async ({
    limit,
    startAfter,
    user,
    userInfo
  }: {
    limit?: number;
    startAfter?: string;
    user?: string;
    userInfo?: UserInfo;
  }): Promise<BasketPositionsResponse[]> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_positions: {
        limit,
        start_after: startAfter,
        user,
        user_info: userInfo
      }
    });
  };
  getBasket = async (): Promise<Basket> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket: {}
    });
  };
  getBasketDebtCaps = async (): Promise<DebtCap[]> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_debt_caps: {}
    });
  };
  getCreditRate = async (): Promise<InterestResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_credit_rate: {}
    });
  };
  getCollateralInterest = async (): Promise<CollateralInterestResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collateral_interest: {}
    });
  };
}
export interface PositionsInterface extends PositionsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    baseDebtCapMultiplier,
    collateralTwapTimeframe,
    cpcMultiplier,
    creditTwapTimeframe,
    debtAuction,
    debtMinimum,
    dexRouter,
    discountsContract,
    liqFee,
    liquidityContract,
    oracleContract,
    oracleTimeLimit,
    osmosisProxy,
    owner,
    rateSlopeMultiplier,
    stabilityPool,
    stakingContract
  }: {
    baseDebtCapMultiplier?: Uint128;
    collateralTwapTimeframe?: number;
    cpcMultiplier?: Decimal;
    creditTwapTimeframe?: number;
    debtAuction?: string;
    debtMinimum?: Uint128;
    dexRouter?: string;
    discountsContract?: string;
    liqFee?: Decimal;
    liquidityContract?: string;
    oracleContract?: string;
    oracleTimeLimit?: number;
    osmosisProxy?: string;
    owner?: string;
    rateSlopeMultiplier?: Decimal;
    stabilityPool?: string;
    stakingContract?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  deposit: ({
    positionId,
    positionOwner
  }: {
    positionId?: Uint128;
    positionOwner?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  increaseDebt: ({
    ltv,
    amount,
    mintToAddr,
    positionId
  }: {
    ltv?: Decimal;
    amount?: Uint128;
    mintToAddr?: string;
    positionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    assets,
    positionId,
    sendTo
  }: {
    assets: Asset[];
    positionId: Uint128;
    sendTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  repay: ({
    positionId,
    positionOwner,
    sendExcessTo
  }: {
    positionId: Uint128;
    positionOwner?: string;
    sendExcessTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liqRepay: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liquidate: ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  redeemCollateral: ({
    maxCollateralPremium
  }: {
    maxCollateralPremium?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  editRedeemability: ({
    maxLoanRepayment,
    positionIds,
    premium,
    redeemable,
    restrictedCollateralAssets
  }: {
    maxLoanRepayment?: Decimal;
    positionIds: Uint128[];
    premium?: number;
    redeemable?: boolean;
    restrictedCollateralAssets?: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  accrue: ({
    positionIds,
    positionOwner
  }: {
    positionIds: Uint128[];
    positionOwner?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  editBasket: ({
    addedCAsset,
    baseInterestRate,
    collateralSupplyCaps,
    cpcMarginOfError,
    creditAssetTwapPriceSource,
    creditPoolInfos,
    frozen,
    liqQueue,
    multiAssetSupplyCaps,
    negativeRates,
    revToStakers,
    takeRevenue
  }: {
    addedCAsset?: CAsset;
    baseInterestRate?: Decimal;
    collateralSupplyCaps?: SupplyCap[];
    cpcMarginOfError?: Decimal;
    creditAssetTwapPriceSource?: TWAPPoolInfo;
    creditPoolInfos?: PoolType[];
    frozen?: boolean;
    liqQueue?: string;
    multiAssetSupplyCaps?: MultiAssetSupplyCap[];
    negativeRates?: boolean;
    revToStakers?: boolean;
    takeRevenue?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  editcAsset: ({
    asset,
    maxLTV,
    maxBorrowLTV
  }: {
    asset: NativeToken;
    maxLTV?: Decimal;
    maxBorrowLTV?: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  callback: (callbackMsg: CallbackMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class PositionsClient extends PositionsQueryClient implements PositionsInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.deposit = this.deposit.bind(this);
    this.increaseDebt = this.increaseDebt.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.repay = this.repay.bind(this);
    this.liqRepay = this.liqRepay.bind(this);
    this.liquidate = this.liquidate.bind(this);
    this.redeemCollateral = this.redeemCollateral.bind(this);
    this.editRedeemability = this.editRedeemability.bind(this);
    this.accrue = this.accrue.bind(this);
    this.editBasket = this.editBasket.bind(this);
    this.editcAsset = this.editcAsset.bind(this);
    this.callback = this.callback.bind(this);
  }

  updateConfig = async ({
    baseDebtCapMultiplier,
    collateralTwapTimeframe,
    cpcMultiplier,
    creditTwapTimeframe,
    debtAuction,
    debtMinimum,
    dexRouter,
    discountsContract,
    liqFee,
    liquidityContract,
    oracleContract,
    oracleTimeLimit,
    osmosisProxy,
    owner,
    rateSlopeMultiplier,
    stabilityPool,
    stakingContract
  }: {
    baseDebtCapMultiplier?: Uint128;
    collateralTwapTimeframe?: number;
    cpcMultiplier?: Decimal;
    creditTwapTimeframe?: number;
    debtAuction?: string;
    debtMinimum?: Uint128;
    dexRouter?: string;
    discountsContract?: string;
    liqFee?: Decimal;
    liquidityContract?: string;
    oracleContract?: string;
    oracleTimeLimit?: number;
    osmosisProxy?: string;
    owner?: string;
    rateSlopeMultiplier?: Decimal;
    stabilityPool?: string;
    stakingContract?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        base_debt_cap_multiplier: baseDebtCapMultiplier,
        collateral_twap_timeframe: collateralTwapTimeframe,
        cpc_multiplier: cpcMultiplier,
        credit_twap_timeframe: creditTwapTimeframe,
        debt_auction: debtAuction,
        debt_minimum: debtMinimum,
        dex_router: dexRouter,
        discounts_contract: discountsContract,
        liq_fee: liqFee,
        liquidity_contract: liquidityContract,
        oracle_contract: oracleContract,
        oracle_time_limit: oracleTimeLimit,
        osmosis_proxy: osmosisProxy,
        owner,
        rate_slope_multiplier: rateSlopeMultiplier,
        stability_pool: stabilityPool,
        staking_contract: stakingContract
      }
    }, fee, memo, _funds);
  };
  deposit = async ({
    positionId,
    positionOwner
  }: {
    positionId?: Uint128;
    positionOwner?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit: {
        position_id: positionId,
        position_owner: positionOwner
      }
    }, fee, memo, _funds);
  };
  increaseDebt = async ({
    ltv,
    amount,
    mintToAddr,
    positionId
  }: {
    ltv?: Decimal;
    amount?: Uint128;
    mintToAddr?: string;
    positionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      increase_debt: {
        LTV: ltv,
        amount,
        mint_to_addr: mintToAddr,
        position_id: positionId
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    assets,
    positionId,
    sendTo
  }: {
    assets: Asset[];
    positionId: Uint128;
    sendTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        assets,
        position_id: positionId,
        send_to: sendTo
      }
    }, fee, memo, _funds);
  };
  repay = async ({
    positionId,
    positionOwner,
    sendExcessTo
  }: {
    positionId: Uint128;
    positionOwner?: string;
    sendExcessTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      repay: {
        position_id: positionId,
        position_owner: positionOwner,
        send_excess_to: sendExcessTo
      }
    }, fee, memo, _funds);
  };
  liqRepay = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liq_repay: {}
    }, fee, memo, _funds);
  };
  liquidate = async ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liquidate: {
        position_id: positionId,
        position_owner: positionOwner
      }
    }, fee, memo, _funds);
  };
  redeemCollateral = async ({
    maxCollateralPremium
  }: {
    maxCollateralPremium?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      redeem_collateral: {
        max_collateral_premium: maxCollateralPremium
      }
    }, fee, memo, _funds);
  };
  editRedeemability = async ({
    maxLoanRepayment,
    positionIds,
    premium,
    redeemable,
    restrictedCollateralAssets
  }: {
    maxLoanRepayment?: Decimal;
    positionIds: Uint128[];
    premium?: number;
    redeemable?: boolean;
    restrictedCollateralAssets?: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_redeemability: {
        max_loan_repayment: maxLoanRepayment,
        position_ids: positionIds,
        premium,
        redeemable,
        restricted_collateral_assets: restrictedCollateralAssets
      }
    }, fee, memo, _funds);
  };
  accrue = async ({
    positionIds,
    positionOwner
  }: {
    positionIds: Uint128[];
    positionOwner?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accrue: {
        position_ids: positionIds,
        position_owner: positionOwner
      }
    }, fee, memo, _funds);
  };
  editBasket = async ({
    addedCAsset,
    baseInterestRate,
    collateralSupplyCaps,
    cpcMarginOfError,
    creditAssetTwapPriceSource,
    creditPoolInfos,
    frozen,
    liqQueue,
    multiAssetSupplyCaps,
    negativeRates,
    revToStakers,
    takeRevenue
  }: {
    addedCAsset?: CAsset;
    baseInterestRate?: Decimal;
    collateralSupplyCaps?: SupplyCap[];
    cpcMarginOfError?: Decimal;
    creditAssetTwapPriceSource?: TWAPPoolInfo;
    creditPoolInfos?: PoolType[];
    frozen?: boolean;
    liqQueue?: string;
    multiAssetSupplyCaps?: MultiAssetSupplyCap[];
    negativeRates?: boolean;
    revToStakers?: boolean;
    takeRevenue?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_basket: {
        added_cAsset: addedCAsset,
        base_interest_rate: baseInterestRate,
        collateral_supply_caps: collateralSupplyCaps,
        cpc_margin_of_error: cpcMarginOfError,
        credit_asset_twap_price_source: creditAssetTwapPriceSource,
        credit_pool_infos: creditPoolInfos,
        frozen,
        liq_queue: liqQueue,
        multi_asset_supply_caps: multiAssetSupplyCaps,
        negative_rates: negativeRates,
        rev_to_stakers: revToStakers,
        take_revenue: takeRevenue
      }
    }, fee, memo, _funds);
  };
  editcAsset = async ({
    asset,
    maxLTV,
    maxBorrowLTV
  }: {
    asset: NativeToken;
    maxLTV?: Decimal;
    maxBorrowLTV?: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      editc_asset: {
        asset,
        max_LTV: maxLTV,
        max_borrow_LTV: maxBorrowLTV
      }
    }, fee, memo, _funds);
  };
  callback = async (callbackMsg: CallbackMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      callback: callbackMsg
    }, fee, memo, _funds);
  };
}