/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Decimal, Addr, Config, ExecuteMsg, CosmosMsgForEmpty, BankMsg, StakingMsg, DistributionMsg, Binary, IbcMsg, Timestamp, Uint64, WasmMsg, GovMsg, VoteOption, ProposalVoteOption, ProposalMessage, Coin, Empty, IbcTimeout, IbcTimeoutBlock, UpdateConfig, InstantiateMsg, ProposalStatus, ProposalListResponse, ProposalResponse, ProposalVotesResponse, Proposal, QueryMsg } from "./Governance.types";
import { GovernanceQueryClient, GovernanceClient } from "./Governance.client";
export const governanceQueryKeys = {
  contract: ([{
    contract: "governance"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...governanceQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  activeProposals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "active_proposals",
    args
  }] as const),
  pendingProposals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "pending_proposals",
    args
  }] as const),
  proposalVoters: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "proposal_voters",
    args
  }] as const),
  proposal: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "proposal",
    args
  }] as const),
  proposalVotes: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "proposal_votes",
    args
  }] as const),
  userVotingPower: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "user_voting_power",
    args
  }] as const),
  totalVotingPower: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...governanceQueryKeys.address(contractAddress)[0],
    method: "total_voting_power",
    args
  }] as const)
};
export const governanceQueries = {
  config: <TData = ConfigResponse,>({
    client,
    options
  }: GovernanceConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  activeProposals: <TData = ActiveProposalsResponse,>({
    client,
    args,
    options
  }: GovernanceActiveProposalsQuery<TData>): UseQueryOptions<ActiveProposalsResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.activeProposals(client?.contractAddress, args),
    queryFn: () => client ? client.activeProposals({
      limit: args.limit,
      start: args.start
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  pendingProposals: <TData = PendingProposalsResponse,>({
    client,
    args,
    options
  }: GovernancePendingProposalsQuery<TData>): UseQueryOptions<PendingProposalsResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.pendingProposals(client?.contractAddress, args),
    queryFn: () => client ? client.pendingProposals({
      limit: args.limit,
      start: args.start
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposalVoters: <TData = ProposalVotersResponse,>({
    client,
    args,
    options
  }: GovernanceProposalVotersQuery<TData>): UseQueryOptions<ProposalVotersResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.proposalVoters(client?.contractAddress, args),
    queryFn: () => client ? client.proposalVoters({
      limit: args.limit,
      proposalId: args.proposalId,
      specificUser: args.specificUser,
      start: args.start,
      voteOption: args.voteOption
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposal: <TData = ProposalResponse,>({
    client,
    args,
    options
  }: GovernanceProposalQuery<TData>): UseQueryOptions<ProposalResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.proposal(client?.contractAddress, args),
    queryFn: () => client ? client.proposal({
      proposalId: args.proposalId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposalVotes: <TData = ProposalVotesResponse,>({
    client,
    args,
    options
  }: GovernanceProposalVotesQuery<TData>): UseQueryOptions<ProposalVotesResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.proposalVotes(client?.contractAddress, args),
    queryFn: () => client ? client.proposalVotes({
      proposalId: args.proposalId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userVotingPower: <TData = UserVotingPowerResponse,>({
    client,
    args,
    options
  }: GovernanceUserVotingPowerQuery<TData>): UseQueryOptions<UserVotingPowerResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.userVotingPower(client?.contractAddress, args),
    queryFn: () => client ? client.userVotingPower({
      proposalId: args.proposalId,
      user: args.user,
      vesting: args.vesting
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  totalVotingPower: <TData = TotalVotingPowerResponse,>({
    client,
    args,
    options
  }: GovernanceTotalVotingPowerQuery<TData>): UseQueryOptions<TotalVotingPowerResponse, Error, TData> => ({
    queryKey: governanceQueryKeys.totalVotingPower(client?.contractAddress, args),
    queryFn: () => client ? client.totalVotingPower({
      proposalId: args.proposalId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface GovernanceReactQuery<TResponse, TData = TResponse> {
  client: GovernanceQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface GovernanceTotalVotingPowerQuery<TData> extends GovernanceReactQuery<TotalVotingPowerResponse, TData> {
  args: {
    proposalId: number;
  };
}
export function useGovernanceTotalVotingPowerQuery<TData = TotalVotingPowerResponse>({
  client,
  args,
  options
}: GovernanceTotalVotingPowerQuery<TData>) {
  return useQuery<TotalVotingPowerResponse, Error, TData>(governanceQueryKeys.totalVotingPower(client?.contractAddress, args), () => client ? client.totalVotingPower({
    proposalId: args.proposalId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceUserVotingPowerQuery<TData> extends GovernanceReactQuery<UserVotingPowerResponse, TData> {
  args: {
    proposalId: number;
    user: string;
    vesting: boolean;
  };
}
export function useGovernanceUserVotingPowerQuery<TData = UserVotingPowerResponse>({
  client,
  args,
  options
}: GovernanceUserVotingPowerQuery<TData>) {
  return useQuery<UserVotingPowerResponse, Error, TData>(governanceQueryKeys.userVotingPower(client?.contractAddress, args), () => client ? client.userVotingPower({
    proposalId: args.proposalId,
    user: args.user,
    vesting: args.vesting
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceProposalVotesQuery<TData> extends GovernanceReactQuery<ProposalVotesResponse, TData> {
  args: {
    proposalId: number;
  };
}
export function useGovernanceProposalVotesQuery<TData = ProposalVotesResponse>({
  client,
  args,
  options
}: GovernanceProposalVotesQuery<TData>) {
  return useQuery<ProposalVotesResponse, Error, TData>(governanceQueryKeys.proposalVotes(client?.contractAddress, args), () => client ? client.proposalVotes({
    proposalId: args.proposalId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceProposalQuery<TData> extends GovernanceReactQuery<ProposalResponse, TData> {
  args: {
    proposalId: number;
  };
}
export function useGovernanceProposalQuery<TData = ProposalResponse>({
  client,
  args,
  options
}: GovernanceProposalQuery<TData>) {
  return useQuery<ProposalResponse, Error, TData>(governanceQueryKeys.proposal(client?.contractAddress, args), () => client ? client.proposal({
    proposalId: args.proposalId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceProposalVotersQuery<TData> extends GovernanceReactQuery<ProposalVotersResponse, TData> {
  args: {
    limit?: number;
    proposalId: number;
    specificUser?: string;
    start?: number;
    voteOption: ProposalVoteOption;
  };
}
export function useGovernanceProposalVotersQuery<TData = ProposalVotersResponse>({
  client,
  args,
  options
}: GovernanceProposalVotersQuery<TData>) {
  return useQuery<ProposalVotersResponse, Error, TData>(governanceQueryKeys.proposalVoters(client?.contractAddress, args), () => client ? client.proposalVoters({
    limit: args.limit,
    proposalId: args.proposalId,
    specificUser: args.specificUser,
    start: args.start,
    voteOption: args.voteOption
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernancePendingProposalsQuery<TData> extends GovernanceReactQuery<PendingProposalsResponse, TData> {
  args: {
    limit?: number;
    start?: number;
  };
}
export function useGovernancePendingProposalsQuery<TData = PendingProposalsResponse>({
  client,
  args,
  options
}: GovernancePendingProposalsQuery<TData>) {
  return useQuery<PendingProposalsResponse, Error, TData>(governanceQueryKeys.pendingProposals(client?.contractAddress, args), () => client ? client.pendingProposals({
    limit: args.limit,
    start: args.start
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceActiveProposalsQuery<TData> extends GovernanceReactQuery<ActiveProposalsResponse, TData> {
  args: {
    limit?: number;
    start?: number;
  };
}
export function useGovernanceActiveProposalsQuery<TData = ActiveProposalsResponse>({
  client,
  args,
  options
}: GovernanceActiveProposalsQuery<TData>) {
  return useQuery<ActiveProposalsResponse, Error, TData>(governanceQueryKeys.activeProposals(client?.contractAddress, args), () => client ? client.activeProposals({
    limit: args.limit,
    start: args.start
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceConfigQuery<TData> extends GovernanceReactQuery<ConfigResponse, TData> {}
export function useGovernanceConfigQuery<TData = ConfigResponse>({
  client,
  options
}: GovernanceConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(governanceQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface GovernanceUpdateConfigMutation {
  client: GovernanceClient;
  msg: {
    expeditedProposalVotingPeriod?: number;
    mbrnDenom?: string;
    minimumTotalStake?: Uint128;
    proposalEffectiveDelay?: number;
    proposalExpirationPeriod?: number;
    proposalRequiredQuorum?: string;
    proposalRequiredStake?: number;
    proposalRequiredThreshold?: string;
    proposalVotingPeriod?: number;
    quadraticVoting?: boolean;
    stakingContract?: string;
    vestingContractAddr?: string;
    vestingVotingPowerMultiplier?: Decimal;
    whitelistAdd?: string[];
    whitelistRemove?: string[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface GovernanceRemoveCompletedProposalMutation {
  client: GovernanceClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceRemoveCompletedProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceRemoveCompletedProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceRemoveCompletedProposalMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeCompletedProposal(msg, fee, memo, funds), options);
}
export interface GovernanceExecuteProposalMutation {
  client: GovernanceClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceExecuteProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceExecuteProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceExecuteProposalMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.executeProposal(msg, fee, memo, funds), options);
}
export interface GovernanceCheckMessagesPassedMutation {
  client: GovernanceClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceCheckMessagesPassedMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceCheckMessagesPassedMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceCheckMessagesPassedMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.checkMessagesPassed(fee, memo, funds), options);
}
export interface GovernanceCheckMessagesMutation {
  client: GovernanceClient;
  msg: {
    messages: ProposalMessage[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceCheckMessagesMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceCheckMessagesMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceCheckMessagesMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.checkMessages(msg, fee, memo, funds), options);
}
export interface GovernanceEndProposalMutation {
  client: GovernanceClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceEndProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceEndProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceEndProposalMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.endProposal(msg, fee, memo, funds), options);
}
export interface GovernanceCastVoteMutation {
  client: GovernanceClient;
  msg: {
    proposalId: number;
    recipient?: string;
    vote: ProposalVoteOption;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceCastVoteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceCastVoteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceCastVoteMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.castVote(msg, fee, memo, funds), options);
}
export interface GovernanceSubmitProposalMutation {
  client: GovernanceClient;
  msg: {
    description: string;
    expedited: boolean;
    link?: string;
    messages?: ProposalMessage[];
    recipient?: string;
    title: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useGovernanceSubmitProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, GovernanceSubmitProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, GovernanceSubmitProposalMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.submitProposal(msg, fee, memo, funds), options);
}