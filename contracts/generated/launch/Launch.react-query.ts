/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { Addr, Uint128, Config, ExecuteMsg, UpdateConfig, InstantiateMsg, LaunchAddrs, AssetInfo, Lockdrop, LockedUser, Lock, QueryMsg, Decimal, UserRatio } from "./Launch.types";
import { LaunchQueryClient, LaunchClient } from "./Launch.client";
export const launchQueryKeys = {
  contract: ([{
    contract: "launch"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...launchQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...launchQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  lockdrop: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...launchQueryKeys.address(contractAddress)[0],
    method: "lockdrop",
    args
  }] as const),
  contractAddresses: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...launchQueryKeys.address(contractAddress)[0],
    method: "contract_addresses",
    args
  }] as const),
  incentiveDistribution: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...launchQueryKeys.address(contractAddress)[0],
    method: "incentive_distribution",
    args
  }] as const),
  userIncentives: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...launchQueryKeys.address(contractAddress)[0],
    method: "user_incentives",
    args
  }] as const),
  userInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...launchQueryKeys.address(contractAddress)[0],
    method: "user_info",
    args
  }] as const)
};
export const launchQueries = {
  config: <TData = ConfigResponse,>({
    client,
    options
  }: LaunchConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: launchQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  lockdrop: <TData = LockdropResponse,>({
    client,
    options
  }: LaunchLockdropQuery<TData>): UseQueryOptions<LockdropResponse, Error, TData> => ({
    queryKey: launchQueryKeys.lockdrop(client?.contractAddress),
    queryFn: () => client ? client.lockdrop() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  contractAddresses: <TData = ContractAddressesResponse,>({
    client,
    options
  }: LaunchContractAddressesQuery<TData>): UseQueryOptions<ContractAddressesResponse, Error, TData> => ({
    queryKey: launchQueryKeys.contractAddresses(client?.contractAddress),
    queryFn: () => client ? client.contractAddresses() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  incentiveDistribution: <TData = IncentiveDistributionResponse,>({
    client,
    options
  }: LaunchIncentiveDistributionQuery<TData>): UseQueryOptions<IncentiveDistributionResponse, Error, TData> => ({
    queryKey: launchQueryKeys.incentiveDistribution(client?.contractAddress),
    queryFn: () => client ? client.incentiveDistribution() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userIncentives: <TData = UserIncentivesResponse,>({
    client,
    args,
    options
  }: LaunchUserIncentivesQuery<TData>): UseQueryOptions<UserIncentivesResponse, Error, TData> => ({
    queryKey: launchQueryKeys.userIncentives(client?.contractAddress, args),
    queryFn: () => client ? client.userIncentives({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userInfo: <TData = UserInfoResponse,>({
    client,
    args,
    options
  }: LaunchUserInfoQuery<TData>): UseQueryOptions<UserInfoResponse, Error, TData> => ({
    queryKey: launchQueryKeys.userInfo(client?.contractAddress, args),
    queryFn: () => client ? client.userInfo({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface LaunchReactQuery<TResponse, TData = TResponse> {
  client: LaunchQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface LaunchUserInfoQuery<TData> extends LaunchReactQuery<UserInfoResponse, TData> {
  args: {
    user: string;
  };
}
export function useLaunchUserInfoQuery<TData = UserInfoResponse>({
  client,
  args,
  options
}: LaunchUserInfoQuery<TData>) {
  return useQuery<UserInfoResponse, Error, TData>(launchQueryKeys.userInfo(client?.contractAddress, args), () => client ? client.userInfo({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LaunchUserIncentivesQuery<TData> extends LaunchReactQuery<UserIncentivesResponse, TData> {
  args: {
    user: string;
  };
}
export function useLaunchUserIncentivesQuery<TData = UserIncentivesResponse>({
  client,
  args,
  options
}: LaunchUserIncentivesQuery<TData>) {
  return useQuery<UserIncentivesResponse, Error, TData>(launchQueryKeys.userIncentives(client?.contractAddress, args), () => client ? client.userIncentives({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LaunchIncentiveDistributionQuery<TData> extends LaunchReactQuery<IncentiveDistributionResponse, TData> {}
export function useLaunchIncentiveDistributionQuery<TData = IncentiveDistributionResponse>({
  client,
  options
}: LaunchIncentiveDistributionQuery<TData>) {
  return useQuery<IncentiveDistributionResponse, Error, TData>(launchQueryKeys.incentiveDistribution(client?.contractAddress), () => client ? client.incentiveDistribution() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LaunchContractAddressesQuery<TData> extends LaunchReactQuery<ContractAddressesResponse, TData> {}
export function useLaunchContractAddressesQuery<TData = ContractAddressesResponse>({
  client,
  options
}: LaunchContractAddressesQuery<TData>) {
  return useQuery<ContractAddressesResponse, Error, TData>(launchQueryKeys.contractAddresses(client?.contractAddress), () => client ? client.contractAddresses() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LaunchLockdropQuery<TData> extends LaunchReactQuery<LockdropResponse, TData> {}
export function useLaunchLockdropQuery<TData = LockdropResponse>({
  client,
  options
}: LaunchLockdropQuery<TData>) {
  return useQuery<LockdropResponse, Error, TData>(launchQueryKeys.lockdrop(client?.contractAddress), () => client ? client.lockdrop() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LaunchConfigQuery<TData> extends LaunchReactQuery<ConfigResponse, TData> {}
export function useLaunchConfigQuery<TData = ConfigResponse>({
  client,
  options
}: LaunchConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(launchQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LaunchUpdateConfigMutation {
  client: LaunchClient;
  msg: {
    creditDenom?: string;
    mbrnDenom?: string;
    osmoDenom?: string;
    usdcDenom?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLaunchUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LaunchUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LaunchUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface LaunchLaunchMutation {
  client: LaunchClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLaunchLaunchMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LaunchLaunchMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LaunchLaunchMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.launch(fee, memo, funds), options);
}
export interface LaunchClaimMutation {
  client: LaunchClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLaunchClaimMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LaunchClaimMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LaunchClaimMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claim(fee, memo, funds), options);
}
export interface LaunchWithdrawMutation {
  client: LaunchClient;
  msg: {
    lockUpDuration: number;
    withdrawalAmount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLaunchWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LaunchWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LaunchWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdraw(msg, fee, memo, funds), options);
}
export interface LaunchChangeLockDurationMutation {
  client: LaunchClient;
  msg: {
    newLockUpDuration: number;
    oldLockUpDuration: number;
    uosmoAmount?: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLaunchChangeLockDurationMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LaunchChangeLockDurationMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LaunchChangeLockDurationMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.changeLockDuration(msg, fee, memo, funds), options);
}
export interface LaunchLockMutation {
  client: LaunchClient;
  msg: {
    lockUpDuration: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLaunchLockMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LaunchLockMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LaunchLockMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.lock(msg, fee, memo, funds), options);
}