/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, AssetInfo, Addr, Decimal, AssetPool, Asset, Deposit, ClaimsResponse, Coin, Config, DepositPositionResponse, ExecuteMsg, UpdateConfig, UserInfo, InstantiateMsg, LiquidatibleResponse, QueryMsg } from "./StabilityPool.types";
import { StabilityPoolQueryClient, StabilityPoolClient } from "./StabilityPool.client";
export const stabilityPoolQueryKeys = {
  contract: ([{
    contract: "stabilityPool"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...stabilityPoolQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stabilityPoolQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  unclaimedIncentives: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stabilityPoolQueryKeys.address(contractAddress)[0],
    method: "unclaimed_incentives",
    args
  }] as const),
  capitalAheadOfDeposit: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stabilityPoolQueryKeys.address(contractAddress)[0],
    method: "capital_ahead_of_deposit",
    args
  }] as const),
  checkLiquidatible: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stabilityPoolQueryKeys.address(contractAddress)[0],
    method: "check_liquidatible",
    args
  }] as const),
  userClaims: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stabilityPoolQueryKeys.address(contractAddress)[0],
    method: "user_claims",
    args
  }] as const),
  assetPool: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stabilityPoolQueryKeys.address(contractAddress)[0],
    method: "asset_pool",
    args
  }] as const)
};
export const stabilityPoolQueries = {
  config: <TData = ConfigResponse,>({
    client,
    options
  }: StabilityPoolConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: stabilityPoolQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  unclaimedIncentives: <TData = UnclaimedIncentivesResponse,>({
    client,
    args,
    options
  }: StabilityPoolUnclaimedIncentivesQuery<TData>): UseQueryOptions<UnclaimedIncentivesResponse, Error, TData> => ({
    queryKey: stabilityPoolQueryKeys.unclaimedIncentives(client?.contractAddress, args),
    queryFn: () => client ? client.unclaimedIncentives({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  capitalAheadOfDeposit: <TData = CapitalAheadOfDepositResponse,>({
    client,
    args,
    options
  }: StabilityPoolCapitalAheadOfDepositQuery<TData>): UseQueryOptions<CapitalAheadOfDepositResponse, Error, TData> => ({
    queryKey: stabilityPoolQueryKeys.capitalAheadOfDeposit(client?.contractAddress, args),
    queryFn: () => client ? client.capitalAheadOfDeposit({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  checkLiquidatible: <TData = CheckLiquidatibleResponse,>({
    client,
    args,
    options
  }: StabilityPoolCheckLiquidatibleQuery<TData>): UseQueryOptions<CheckLiquidatibleResponse, Error, TData> => ({
    queryKey: stabilityPoolQueryKeys.checkLiquidatible(client?.contractAddress, args),
    queryFn: () => client ? client.checkLiquidatible({
      amount: args.amount
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userClaims: <TData = UserClaimsResponse,>({
    client,
    args,
    options
  }: StabilityPoolUserClaimsQuery<TData>): UseQueryOptions<UserClaimsResponse, Error, TData> => ({
    queryKey: stabilityPoolQueryKeys.userClaims(client?.contractAddress, args),
    queryFn: () => client ? client.userClaims({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  assetPool: <TData = AssetPoolResponse,>({
    client,
    args,
    options
  }: StabilityPoolAssetPoolQuery<TData>): UseQueryOptions<AssetPoolResponse, Error, TData> => ({
    queryKey: stabilityPoolQueryKeys.assetPool(client?.contractAddress, args),
    queryFn: () => client ? client.assetPool({
      depositLimit: args.depositLimit,
      startAfter: args.startAfter,
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface StabilityPoolReactQuery<TResponse, TData = TResponse> {
  client: StabilityPoolQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface StabilityPoolAssetPoolQuery<TData> extends StabilityPoolReactQuery<AssetPoolResponse, TData> {
  args: {
    depositLimit?: number;
    startAfter?: number;
    user?: string;
  };
}
export function useStabilityPoolAssetPoolQuery<TData = AssetPoolResponse>({
  client,
  args,
  options
}: StabilityPoolAssetPoolQuery<TData>) {
  return useQuery<AssetPoolResponse, Error, TData>(stabilityPoolQueryKeys.assetPool(client?.contractAddress, args), () => client ? client.assetPool({
    depositLimit: args.depositLimit,
    startAfter: args.startAfter,
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StabilityPoolUserClaimsQuery<TData> extends StabilityPoolReactQuery<UserClaimsResponse, TData> {
  args: {
    user: string;
  };
}
export function useStabilityPoolUserClaimsQuery<TData = UserClaimsResponse>({
  client,
  args,
  options
}: StabilityPoolUserClaimsQuery<TData>) {
  return useQuery<UserClaimsResponse, Error, TData>(stabilityPoolQueryKeys.userClaims(client?.contractAddress, args), () => client ? client.userClaims({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StabilityPoolCheckLiquidatibleQuery<TData> extends StabilityPoolReactQuery<CheckLiquidatibleResponse, TData> {
  args: {
    amount: Decimal;
  };
}
export function useStabilityPoolCheckLiquidatibleQuery<TData = CheckLiquidatibleResponse>({
  client,
  args,
  options
}: StabilityPoolCheckLiquidatibleQuery<TData>) {
  return useQuery<CheckLiquidatibleResponse, Error, TData>(stabilityPoolQueryKeys.checkLiquidatible(client?.contractAddress, args), () => client ? client.checkLiquidatible({
    amount: args.amount
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StabilityPoolCapitalAheadOfDepositQuery<TData> extends StabilityPoolReactQuery<CapitalAheadOfDepositResponse, TData> {
  args: {
    user: string;
  };
}
export function useStabilityPoolCapitalAheadOfDepositQuery<TData = CapitalAheadOfDepositResponse>({
  client,
  args,
  options
}: StabilityPoolCapitalAheadOfDepositQuery<TData>) {
  return useQuery<CapitalAheadOfDepositResponse, Error, TData>(stabilityPoolQueryKeys.capitalAheadOfDeposit(client?.contractAddress, args), () => client ? client.capitalAheadOfDeposit({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StabilityPoolUnclaimedIncentivesQuery<TData> extends StabilityPoolReactQuery<UnclaimedIncentivesResponse, TData> {
  args: {
    user: string;
  };
}
export function useStabilityPoolUnclaimedIncentivesQuery<TData = UnclaimedIncentivesResponse>({
  client,
  args,
  options
}: StabilityPoolUnclaimedIncentivesQuery<TData>) {
  return useQuery<UnclaimedIncentivesResponse, Error, TData>(stabilityPoolQueryKeys.unclaimedIncentives(client?.contractAddress, args), () => client ? client.unclaimedIncentives({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StabilityPoolConfigQuery<TData> extends StabilityPoolReactQuery<ConfigResponse, TData> {}
export function useStabilityPoolConfigQuery<TData = ConfigResponse>({
  client,
  options
}: StabilityPoolConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(stabilityPoolQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StabilityPoolRepayMutation {
  client: StabilityPoolClient;
  msg: {
    repayment: Asset;
    userInfo: UserInfo;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolRepayMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolRepayMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolRepayMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.repay(msg, fee, memo, funds), options);
}
export interface StabilityPoolDistributeMutation {
  client: StabilityPoolClient;
  msg: {
    distributeFor: Uint128;
    distributionAssetRatios: Decimal[];
    distributionAssets: Asset[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolDistributeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolDistributeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolDistributeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.distribute(msg, fee, memo, funds), options);
}
export interface StabilityPoolLiquidateMutation {
  client: StabilityPoolClient;
  msg: {
    liqAmount: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolLiquidateMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolLiquidateMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolLiquidateMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.liquidate(msg, fee, memo, funds), options);
}
export interface StabilityPoolClaimRewardsMutation {
  client: StabilityPoolClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolClaimRewardsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolClaimRewardsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolClaimRewardsMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimRewards(fee, memo, funds), options);
}
export interface StabilityPoolRestakeMutation {
  client: StabilityPoolClient;
  msg: {
    restakeAmount: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolRestakeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolRestakeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolRestakeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.restake(msg, fee, memo, funds), options);
}
export interface StabilityPoolWithdrawMutation {
  client: StabilityPoolClient;
  msg: {
    amount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdraw(msg, fee, memo, funds), options);
}
export interface StabilityPoolDepositMutation {
  client: StabilityPoolClient;
  msg: {
    user?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolDepositMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolDepositMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolDepositMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.deposit(msg, fee, memo, funds), options);
}
export interface StabilityPoolUpdateConfigMutation {
  client: StabilityPoolClient;
  msg: {
    incentiveRate?: Decimal;
    maxIncentives?: Uint128;
    mbrnDenom?: string;
    minimumDepositAmount?: Uint128;
    osmosisProxy?: string;
    owner?: string;
    positionsContract?: string;
    unstakingPeriod?: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStabilityPoolUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StabilityPoolUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StabilityPoolUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}