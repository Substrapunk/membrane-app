/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { Addr, Decimal, Config, StakeDistribution, Uint128, DelegationResponse, DelegationInfo, Delegation, ExecuteMsg, AssetInfo, FeeEventsResponse, FeeEvent, LiqAsset, InstantiateMsg, QueryMsg, RewardsResponse, Asset, StakeDistributionLog, StakedResponse, StakeDeposit, StakerResponse, TotalStakedResponse } from "./Staking.types";
import { StakingQueryClient, StakingClient } from "./Staking.client";
export const stakingQueryKeys = {
  contract: ([{
    contract: "staking"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...stakingQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  userStake: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "user_stake",
    args
  }] as const),
  userRewards: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "user_rewards",
    args
  }] as const),
  staked: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "staked",
    args
  }] as const),
  delegations: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "delegations",
    args
  }] as const),
  feeEvents: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "fee_events",
    args
  }] as const),
  totalStaked: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "total_staked",
    args
  }] as const),
  incentiveSchedule: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...stakingQueryKeys.address(contractAddress)[0],
    method: "incentive_schedule",
    args
  }] as const)
};
export const stakingQueries = {
  config: <TData = ConfigResponse,>({
    client,
    options
  }: StakingConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userStake: <TData = UserStakeResponse,>({
    client,
    args,
    options
  }: StakingUserStakeQuery<TData>): UseQueryOptions<UserStakeResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.userStake(client?.contractAddress, args),
    queryFn: () => client ? client.userStake({
      staker: args.staker
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userRewards: <TData = UserRewardsResponse,>({
    client,
    args,
    options
  }: StakingUserRewardsQuery<TData>): UseQueryOptions<UserRewardsResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.userRewards(client?.contractAddress, args),
    queryFn: () => client ? client.userRewards({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  staked: <TData = StakedResponse,>({
    client,
    args,
    options
  }: StakingStakedQuery<TData>): UseQueryOptions<StakedResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.staked(client?.contractAddress, args),
    queryFn: () => client ? client.staked({
      endBefore: args.endBefore,
      limit: args.limit,
      startAfter: args.startAfter,
      unstaking: args.unstaking
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  delegations: <TData = DelegationsResponse,>({
    client,
    args,
    options
  }: StakingDelegationsQuery<TData>): UseQueryOptions<DelegationsResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.delegations(client?.contractAddress, args),
    queryFn: () => client ? client.delegations({
      limit: args.limit,
      startAfter: args.startAfter,
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  feeEvents: <TData = FeeEventsResponse,>({
    client,
    args,
    options
  }: StakingFeeEventsQuery<TData>): UseQueryOptions<FeeEventsResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.feeEvents(client?.contractAddress, args),
    queryFn: () => client ? client.feeEvents({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  totalStaked: <TData = TotalStakedResponse,>({
    client,
    options
  }: StakingTotalStakedQuery<TData>): UseQueryOptions<TotalStakedResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.totalStaked(client?.contractAddress),
    queryFn: () => client ? client.totalStaked() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  incentiveSchedule: <TData = IncentiveScheduleResponse,>({
    client,
    options
  }: StakingIncentiveScheduleQuery<TData>): UseQueryOptions<IncentiveScheduleResponse, Error, TData> => ({
    queryKey: stakingQueryKeys.incentiveSchedule(client?.contractAddress),
    queryFn: () => client ? client.incentiveSchedule() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface StakingReactQuery<TResponse, TData = TResponse> {
  client: StakingQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface StakingIncentiveScheduleQuery<TData> extends StakingReactQuery<IncentiveScheduleResponse, TData> {}
export function useStakingIncentiveScheduleQuery<TData = IncentiveScheduleResponse>({
  client,
  options
}: StakingIncentiveScheduleQuery<TData>) {
  return useQuery<IncentiveScheduleResponse, Error, TData>(stakingQueryKeys.incentiveSchedule(client?.contractAddress), () => client ? client.incentiveSchedule() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingTotalStakedQuery<TData> extends StakingReactQuery<TotalStakedResponse, TData> {}
export function useStakingTotalStakedQuery<TData = TotalStakedResponse>({
  client,
  options
}: StakingTotalStakedQuery<TData>) {
  return useQuery<TotalStakedResponse, Error, TData>(stakingQueryKeys.totalStaked(client?.contractAddress), () => client ? client.totalStaked() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingFeeEventsQuery<TData> extends StakingReactQuery<FeeEventsResponse, TData> {
  args: {
    limit?: number;
    startAfter?: number;
  };
}
export function useStakingFeeEventsQuery<TData = FeeEventsResponse>({
  client,
  args,
  options
}: StakingFeeEventsQuery<TData>) {
  return useQuery<FeeEventsResponse, Error, TData>(stakingQueryKeys.feeEvents(client?.contractAddress, args), () => client ? client.feeEvents({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingDelegationsQuery<TData> extends StakingReactQuery<DelegationsResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
    user?: string;
  };
}
export function useStakingDelegationsQuery<TData = DelegationsResponse>({
  client,
  args,
  options
}: StakingDelegationsQuery<TData>) {
  return useQuery<DelegationsResponse, Error, TData>(stakingQueryKeys.delegations(client?.contractAddress, args), () => client ? client.delegations({
    limit: args.limit,
    startAfter: args.startAfter,
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingStakedQuery<TData> extends StakingReactQuery<StakedResponse, TData> {
  args: {
    endBefore?: number;
    limit?: number;
    startAfter?: number;
    unstaking: boolean;
  };
}
export function useStakingStakedQuery<TData = StakedResponse>({
  client,
  args,
  options
}: StakingStakedQuery<TData>) {
  return useQuery<StakedResponse, Error, TData>(stakingQueryKeys.staked(client?.contractAddress, args), () => client ? client.staked({
    endBefore: args.endBefore,
    limit: args.limit,
    startAfter: args.startAfter,
    unstaking: args.unstaking
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingUserRewardsQuery<TData> extends StakingReactQuery<UserRewardsResponse, TData> {
  args: {
    user: string;
  };
}
export function useStakingUserRewardsQuery<TData = UserRewardsResponse>({
  client,
  args,
  options
}: StakingUserRewardsQuery<TData>) {
  return useQuery<UserRewardsResponse, Error, TData>(stakingQueryKeys.userRewards(client?.contractAddress, args), () => client ? client.userRewards({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingUserStakeQuery<TData> extends StakingReactQuery<UserStakeResponse, TData> {
  args: {
    staker: string;
  };
}
export function useStakingUserStakeQuery<TData = UserStakeResponse>({
  client,
  args,
  options
}: StakingUserStakeQuery<TData>) {
  return useQuery<UserStakeResponse, Error, TData>(stakingQueryKeys.userStake(client?.contractAddress, args), () => client ? client.userStake({
    staker: args.staker
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingConfigQuery<TData> extends StakingReactQuery<ConfigResponse, TData> {}
export function useStakingConfigQuery<TData = ConfigResponse>({
  client,
  options
}: StakingConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(stakingQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StakingTrimFeeEventsMutation {
  client: StakingClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingTrimFeeEventsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingTrimFeeEventsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingTrimFeeEventsMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.trimFeeEvents(fee, memo, funds), options);
}
export interface StakingDepositFeeMutation {
  client: StakingClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingDepositFeeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingDepositFeeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingDepositFeeMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.depositFee(fee, memo, funds), options);
}
export interface StakingDelegateFluidDelegationsMutation {
  client: StakingClient;
  msg: {
    governatorAddr: string;
    mbrnAmount?: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingDelegateFluidDelegationsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingDelegateFluidDelegationsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingDelegateFluidDelegationsMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.delegateFluidDelegations(msg, fee, memo, funds), options);
}
export interface StakingUpdateDelegationsMutation {
  client: StakingClient;
  msg: {
    commission?: Decimal;
    delegate?: boolean;
    fluid?: boolean;
    governatorAddr?: string;
    mbrnAmount?: Uint128;
    votingPowerDelegation?: boolean;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingUpdateDelegationsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingUpdateDelegationsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingUpdateDelegationsMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateDelegations(msg, fee, memo, funds), options);
}
export interface StakingClaimRewardsMutation {
  client: StakingClient;
  msg: {
    restake: boolean;
    sendTo?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingClaimRewardsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingClaimRewardsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingClaimRewardsMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimRewards(msg, fee, memo, funds), options);
}
export interface StakingRestakeMutation {
  client: StakingClient;
  msg: {
    mbrnAmount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingRestakeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingRestakeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingRestakeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.restake(msg, fee, memo, funds), options);
}
export interface StakingUnstakeMutation {
  client: StakingClient;
  msg: {
    mbrnAmount?: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingUnstakeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingUnstakeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingUnstakeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.unstake(msg, fee, memo, funds), options);
}
export interface StakingStakeMutation {
  client: StakingClient;
  msg: {
    user?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingStakeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingStakeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingStakeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.stake(msg, fee, memo, funds), options);
}
export interface StakingUpdateConfigMutation {
  client: StakingClient;
  msg: {
    auctionContract?: string;
    feeWaitPeriod?: number;
    governanceContract?: string;
    incentiveSchedule?: StakeDistribution;
    keepRawCdt?: boolean;
    maxCommissionRate?: Decimal;
    mbrnDenom?: string;
    osmosisProxy?: string;
    owner?: string;
    positionsContract?: string;
    unstakingPeriod?: number;
    vestingContract?: string;
    vestingRevMultiplier?: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStakingUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StakingUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StakingUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}